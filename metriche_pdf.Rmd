---
title: "metriche"
author: "Enrico Gabrielli F.A.R.M. Facilitazioni Agroecologiche Regionali Mobili"
date: "17/1/2023"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# VINDICTA progetto 16.1 PSR Emilia-Romagna 2014-2020

## azione 3, analisi agroecosistema

### Calcolo delle metriche di analisi dell'agroecosistema

```{r pacchetti, echo=FALSE, message=FALSE}
library(raster) # per analizzare il raster
library(httr)
library(tidyverse)
library(ggplot2)
library(terrainr)
library(patchwork)
library(stringr)
library(gridExtra)
```

### Visualizzazione della resistenza

```{r resistance carico del dato e costruzione del plot, echo=FALSE, message=FALSE}
cartella <- './raster' #cartella in cui si trovano i raster in formato tif
files <- list.files(path = cartella,pattern = '*resistance_norm.tif',full.names = T)
resistance_norm <- vector("list", length(files))
names(resistance_norm) <- str_extract(files, "(?<=\\+)[[:alpha:]]+(?=_)") #i file iniziano con + e con il nome dell'azienda
for (i in 1:length(files)) { # importo i raster
  resistance_norm[[i]] <- raster(files[i])
}
#di seguito i passaggi per usare ggplot2 per visualizzare la carta
resistance_norm_df <- lapply(resistance_norm,function(x) #ggplot usa dei dataframe
  raster::as.data.frame(x,xy=TRUE #quindi trasformo i raster in dataframe
                        ,centroids=T
#                        ,row.names = c("x","y","value")
                        )
  )
nomecolonne <- c("x","y","value") #il valore ha il nome del raster, voglio lo stesso x tutti i raster
resistance_norm_df <- lapply(resistance_norm_df,setNames,nomecolonne)
fun_plot_resistance <- function(x) ggplot(x)+ #funzione per l'heatmap
  geom_tile(aes(x=x,y=y,fill=value))+
    scale_fill_distiller(type="seq",palette = "Reds",direction=-1)+ #direction=-1 è per invertire i gradienti
  coord_fixed() #per avere un quadrato sempre
plot_resistance_norm <- lapply(resistance_norm_df,fun_plot_resistance)
do.call("grid.arrange", c(plot_resistance_norm, ncol = length(plot_resistance_norm))) #grid.arrange serve a visualizzare i plot nella lista uno a fianco dell'altro (tante colonne quanti sono i plot nella lista)
```

```{r violin plot resistenza, echo=FALSE, message=FALSE}
#non posso far diventare la lista di dataframe dai raster un solo dataframe, perché potrebbero essere di diversa grandezza. quindi devo lavorare direttamente su resistance_norm_df già creato in precedenza, cioé la lista di dataframe
fun_violin_plot <- function(df) gg <- ggplot(df,aes(x='',y=value)) +
  geom_violin(na.rm = T) #funzione di ggplot per grafici a violino (boxplot+density). x bisogna segnarlo
resistance_violin_plot <- lapply(resistance_norm_df,fun_violin_plot) #la funzione va per ogni oggetto della lista di dataframe dei valori ricavati dai raster
nomi_plot <- as.list(names(resistance_norm_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
fun_nomi_plot <- function(plot,nomi) {plot + ggtitle(nomi)} #funzione per aggiungere il titolo ai plot già creati
resistance_violin_plot <- mapply(plot=resistance_violin_plot,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
resistance_norm_df_v <- lapply(resistance_norm,function(x) #creare una lista di vettori solo con i valori per fare le medie
  as.vector(x))
media_plot <- lapply(resistance_norm_df_v,mean) #calcolo la media della resistenza
fun_plot_medie <- function(plot,medie) {plot + geom_point(y=medie)} #funzione per aggiungere il punto medio ai plot già creati
resistance_violin_plot <- mapply(plot=resistance_violin_plot,medie=media_plot,fun_plot_medie,SIMPLIFY = F) #aggiungo il punto medio
do.call("grid.arrange", c(resistance_violin_plot, ncol = length(resistance_violin_plot))) #grid.arrange serve a visualizzare i plot nella lista uno a fianco dell'altro (tante colonne quanti sono i plot nella lista)
```

