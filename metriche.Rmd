---
title: "metriche"
author: "Enrico Gabrielli F.A.R.M. Facilitazioni Agroecologiche Regionali Mobili"
date: "17/1/2023"
output:
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# VINDICTA progetto 16.1 PSR Emilia-Romagna 2014-2020

## azione 3, analisi agroecosistema

### Calcolo delle metriche di analisi dell'agroecosistema

I grafici delle metriche sono dei plot a violino, un ibrido tra i boxplot e i density plot:

-   sulla y si trova il continuum di valori di ogni cella per ogni metrica calcolata

-   la larghezza del grafico all'area (ossia al numero di celle) corrispondendi al valore.

```{r pacchetti, message=FALSE, include=FALSE}
library(terra) # per analizzare il raster
library(scales)
library(httr)
library(tidyverse)
library(ggplot2)
library(terrainr)
library(stringr)
library(gridExtra)
library(dplyr)
library(listr)
```

```{r variabili, include=FALSE}
cartella <- './raster/output' #cartella in cui si trovano i raster in formato tif
```

```{r funzioni, include=FALSE}
fun_nomi_plot <- function(plot,nomi) {plot + ggtitle(nomi)} #funzione per aggiungere il titolo ai plot già creati
```

```{r raster files, echo=FALSE}
raster_dir <- list.dirs(path = cartella)
raster_files <- list.files(path=cartella,                #lista di file tif (nelle cartelle ci sono anche i README.md)
                                     pattern = "\\.tif$",
                                     full.names = TRUE,
                                     recursive = T)
rasters <- lapply(raster_files, rast)                   #carico tutti i raster

rast_df <- lapply(rasters,function(x) terra::as.data.frame(x,xy=T))         #per poter fare ggplot trasformo tutto in data.frame

prova <- strsplit(raster_files, "(\\\\|/)+")            #si poteva fare anche con strestract in un solo passaggio, ma non ci sono riuscito
raster_files <- sapply(prova, function(prova) paste0(prova[4],'-',prova[5]))
for (i in seq_along(rast_df)){                          #questo loop serve solo a rinominare i dataframe nella lista, importante perché poi i plot prenderanno qui il titolo
  names(rast_df) <- raster_files
}
rast_df <- lapply(rast_df, setNames, c('x','y','value')) #la colonna dei dataframe deve essere uguale
medie <- lapply(rast_df,function(x) mean(x[,3]))
rast_df_br <- bind_rows(rast_df,.id = "data_frame") #creo un'unica tabella con due colonne, una con il nome del raster, l'altra con i valori
```

```{r heatmap resistenza, message=FALSE, include=FALSE}
resistenza_df <- rast_df[grepl("resistenza", names(rast_df))] #estraggo solo i dataframe della resistanza

fun_plot_resistance <- function(x) ggplot(x,aes(x=x,y=y))+ #funzione per l'heatmap
  geom_tile(aes(fill=value))+
  scale_fill_gradient(low = "green3",
                      high = "white",
                      trans='log',
                      label = function(x) sprintf("%.2f", x),
                      limits=c(0.01, 1) #per avere le legende dei vari plot confrontabili
                      ) +
  theme(legend.position = "bottom",
        legend.title = element_blank(), #rimuovi testi che non servono come "value" in legenda
        legend.key.width = unit(1.5,'cm'), #change legend key width
        ) +
  labs(x = NULL, y = NULL) + #tolgo i label agli assi
  coord_fixed() #per avere un quadrato sempre
plot_resistance <- lapply(resistenza_df,fun_plot_resistance)
nomi_plot <- as.list(names(resistenza_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
plot_resistance_norm <- mapply(plot=plot_resistance,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

#### Metriche di gradiente di paesaggio

Si tratta di metriche dell'intero paesaggio, senza riferimento alla zona di lancio o presenza del parassitoide.

##### Resistenza

Metrica di quanto è resistente al movimento il paesaggio.

-   1= resistenza totale

-   0= resistenza nulla

```{r plot heatmap resistenza, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
do.call(grid.arrange,c(plot_resistance_norm, ncol = (length(raster_files)/(length(raster_dir)-1))))
```

```{r plot resistenza, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"resistenza")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))    
    ) +
  labs(x=NULL,y = NULL)
```

##### Assorbanza

Assorbimento significa impossibilità di movimento, o incapacità di tornare indietro. I valori sono vicini a 1 o vicini a 0.

-   1= assorbanza totale, ovvero mortalità

-   0= assorbanza nulla, ovvero nessun fattore di mortalità

```{r plot assorbanza, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"assorbimento")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))    
    ) +
  labs(x=NULL,y = NULL)
```

#### Metriche SAMC (Spatial Absorbing Markov Chain)

Sono le metriche calcolate dal punto di lancio della vespa samurai, che è il centro del raster.

##### Dispersione

Con dispersione si intende la probabilità che la cella sarà visitata almeno una volta dal parassitoide. Il grafico indica quindi la capacità di dispersione in quel paesaggio per quel punto di lancio.

```{r plot dispersion, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"dispersione")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))
        ) +
  labs(x=NULL,y = NULL)
```

##### Mortalità

Con Mortalità si intende la probabilità di assorbimento nella cella visitata. Il grafico indica quindi la probabilità di "assorbimento" in quel paesaggio per quel punto di lancio

```{r plot mortality, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"mortalita")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))
    ) +
  labs(x=NULL,y = NULL)
```
