---
title: "metriche"
author: "Enrico Gabrielli F.A.R.M. Facilitazioni Agroecologiche Regionali Mobili"
date: "17/1/2023"
bibliography: vindicta_samc.bib
output:
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# VINDICTA progetto 16.1 PSR Emilia-Romagna 2014-2020

## azione 3, analisi agroecosistema

### Calcolo delle metriche di analisi dell'agroecosistema

I grafici delle metriche sono dei plot a violino, un ibrido tra i boxplot e i density plot:

-   sulla y si trova il continuum di valori di ogni cella per ogni metrica calcolata

-   la larghezza del grafico all'area (ossia al numero di celle) corrispondendi al valore.

```{r pacchetti, message=FALSE, include=FALSE}
library(terra) # per analizzare il raster
library(raster)
library(scales)
library(httr)
library(tidyverse)
library(ggplot2)
library(terrainr)
library(stringr)
library(gridExtra)
library(dplyr)
library(listr)
```

```{r variabili, include=FALSE}
cartella <- './cartografia/output' #cartella in cui si trovano i raster in formato tif
```

```{r funzioni, include=FALSE}
fun_nomi_plot <- function(plot,nomi) {plot + ggtitle(nomi)} #funzione per aggiungere il titolo ai plot già creati
```

```{r raster files, echo=FALSE}
raster_dir <- list.dirs(path = cartella)
raster_files <- list.files(path=cartella,                #lista di file tif (nelle cartelle ci sono anche i README.md)
                                     pattern = "\\.tif$",
                                     full.names = TRUE,
                                     recursive = T)
rasters <- lapply(raster_files, rast)                   #carico tutti i raster

rast_df <- lapply(rasters,function(x) terra::as.data.frame(x,xy=T))         #per poter fare ggplot trasformo tutto in data.frame

prova <- strsplit(raster_files, "(\\\\|/)+")            #si poteva fare anche con strextract in un solo passaggio, ma non ci sono riuscito
raster_files <- sapply(prova, function(prova) paste0(prova[4],'-',prova[5]))
for (i in seq_along(rast_df)){                          #questo loop serve solo a rinominare i dataframe nella lista, importante perché poi i plot prenderanno qui il titolo
  names(rast_df) <- raster_files
}
rast_df <- lapply(rast_df, setNames, c('x','y','value')) #la colonna dei dataframe deve essere uguale
medie <- lapply(rast_df,function(x) mean(x[,3]))
rast_df_br <- bind_rows(rast_df,.id = "data_frame") #creo un'unica tabella con due colonne, una con il nome del raster, l'altra con i valori
```

```{r foto_aeree, message=FALSE, include=FALSE}
cartella_foto_aeree <- './cartografia/output/0_foto_aeree'
foto_aeree_files <- list.files(path=cartella_foto_aeree,                #lista di file tif
                           pattern = "\\.tif$",
                           full.names = TRUE,
                           recursive = T)
wms_raster <- mapply(function(x) stack(x),foto_aeree_files) #carico la foto aerea nelle 3 componenti RGB - per una questione di semplicità non assegno l'estensione sul crs

fun_plot_rgb <- function(raster) ggplot() +
  geom_spatial_rgb(
    data = raster,
    mapping = aes(
      x=x,
      y=y,
      r=red,
      g=green,
      b=blue
    )) +
    theme(legend.position = "bottom",
          legend.title = element_blank(), #rimuovi testi che non servono come "value" in legenda
          legend.key.width = unit(1.5,'cm'), #change legend key width
        ) +
  labs(x = NULL, y = NULL) #tolgo i label agli assi

plot_foto_aeree <- lapply(wms_raster,fun_plot_rgb)
nomi_plot <- as.list(names(wms_raster)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
plot_foto_aeree <- mapply(plot=plot_foto_aeree,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

```{r heatmap resistenza, message=FALSE, include=FALSE}
resistenza_df <- rast_df[grepl("resistenza", names(rast_df))] #estraggo solo i dataframe della resistanza

fun_plot_resistance <- function(x) ggplot(x,aes(x=x,y=y))+ #funzione per l'heatmap
  geom_tile(aes(fill=value))+
  scale_fill_gradientn(colours = heat.colors(7),
                      trans='log',
                      label = function(x) sprintf("%.2f", x),
                      limits=c(0.01, 1) #per avere le legende dei vari plot confrontabili
                      ) +
  theme(legend.position = "bottom",
        legend.title = element_blank(), #rimuovi testi che non servono come "value" in legenda
        legend.key.width = unit(1.5,'cm'), #change legend key width
        ) +
  labs(x = NULL, y = NULL) + #tolgo i label agli assi
  coord_fixed() #per avere un quadrato sempre
plot_resistance <- lapply(resistenza_df,fun_plot_resistance)
nomi_plot <- as.list(names(resistenza_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
plot_resistance <- mapply(plot=plot_resistance,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

```{r heatmap assorbimento, message=FALSE, include=FALSE}
assorbimento_df <- rast_df[grepl("assorbimento", names(rast_df))] #estraggo solo i dataframe dell'assorbimento

fun_plot_absorbance <- function(x) ggplot(x,aes(x=x,y=y))+ #funzione per l'heatmap
  stat_contour_filled(aes(z=value,fill='green'),bins = 1,show.legend = F)+
  labs(x = NULL, y = NULL) + #tolgo i label agli assi
  coord_fixed() #per avere un quadrato sempre
plot_absorbance <- lapply(assorbimento_df,fun_plot_absorbance)
nomi_plot <- as.list(names(assorbimento_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
plot_absorbance <- mapply(plot=plot_absorbance,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

```{r heatmap dispersione, message=FALSE, include=FALSE}
dispersione_df <- rast_df[grepl("dispersione", names(rast_df))] #estraggo solo i dataframe della dispersione

fun_plot_dispersion <- function(x) ggplot(x,aes(x=x,y=y))+ #funzione per l'heatmap
  geom_tile(aes(fill=value))+
  scale_fill_gradientn(colours = rev(heat.colors(7)),
                      trans='log10',
                      label = function(x) sprintf("%.2f", x),
                      limits=c(1, 100) #per avere le legende dei vari plot confrontabili
                      ) +
  theme(legend.position = "bottom",
        legend.title = element_blank(), #rimuovi testi che non servono come "value" in legenda
        legend.key.width = unit(1.5,'cm'), #change legend key width
        ) +
  labs(x = NULL, y = NULL) + #tolgo i label agli assi
  coord_fixed() #per avere un quadrato sempre
plot_dispersion <- lapply(dispersione_df,fun_plot_dispersion)
nomi_plot <- as.list(names(dispersione_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
plot_dispersion <- mapply(plot=plot_dispersion,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

```{r heatmap mortalita, message=FALSE, include=FALSE}
mortalita_df <- rast_df[grepl("mortalita", names(rast_df))] #estraggo solo i dataframe della mortalità

fun_plot_mortality <- function(x) ggplot(x,aes(x=x,y=y))+ #funzione per l'heatmap
  geom_tile(aes(fill=value))+
  scale_fill_gradientn(colours = rev(heat.colors(7)),
                      trans='log10',
                      label = function(x) formatC(x, format = "e", digits = 0),
                      limits=c(0.000000001, 100) #per avere le legende dei vari plot confrontabili
                      ) +
  theme(legend.position = "bottom",
        legend.title = element_blank(), #rimuovi testi che non servono come "value" in legenda
        legend.key.width = unit(1.5,'cm'), #change legend key width
        ) +
  labs(x = NULL, y = NULL) + #tolgo i label agli assi
  coord_fixed() #per avere un quadrato sempre
plot_mortality <- lapply(mortalita_df,fun_plot_mortality)
nomi_plot <- as.list(names(mortalita_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
plot_mortality <- mapply(plot=plot_mortality,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

#### Foto aeree 2020 AGREA NIR

Queste sono le foto aeree usate per la fotointerpretazione, tratte da [geoportale Emilia-Romagna \> wms \> ortofoto \> AGREA 2020 NIR](https://geoportale.regione.emilia-romagna.it/servizi/servizi-ogc/elenco-capabilities-dei-servizi-wms/cartografia-di-base/service-35). La fotointepretazione è stata supportata da:

-   elaborazioni LIDAR risoluzione 1 metro del 2008-2013 quando presenti per l'area di studio, per ricavare la posizione delle arboree e le loro altezze.

-   dati AGREA 2021 e 2022, disponibili qui [agreagestione file > AppezzAziendaGrafici](https://agreagestione.regione.emilia-romagna.it/agrea-file/AppezzAziendaGrafici/)
```{r plot foto aeree, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
do.call(grid.arrange,c(plot_foto_aeree, ncol = (length(raster_files)/(length(raster_dir)-1))))
```

#### Metriche di gradiente di paesaggio

Si tratta di metriche dell'intero paesaggio, senza riferimento alla zona di lancio o presenza del parassitoide.

##### Resistenza

Metrica di quanto è resistente al movimento il paesaggio.

-   1= resistenza totale

-   0= resistenza nulla

```{r plot heatmap resistenza, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
do.call(grid.arrange,c(plot_resistance, ncol = (length(raster_files)/(length(raster_dir)-1))))
```

```{r plot resistenza, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"resistenza")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))    
    ) +
  labs(x=NULL,y = NULL)
```

##### Assorbanza

Assorbimento significa impossibilità di movimento, o incapacità di tornare indietro. I valori sono vicini a 1 o vicini a 0.

-   1= assorbanza totale, ovvero mortalità. Nella carta le aree sono quelle trasparenti.

-   0= assorbanza nulla, ovvero nessun fattore di mortalità

```{r plot heatmap assorbimento, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
do.call(grid.arrange,c(plot_absorbance, ncol = (length(raster_files)/(length(raster_dir)-1))))
```

```{r plot assorbanza, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"assorbimento")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))    
    ) +
  labs(x=NULL,y = NULL)
```

#### Metriche SAMC (Spatial Absorbing Markov Chain) @samc

Sono le metriche calcolate dal punto di lancio della vespa samurai, che è il centro del raster.

##### Dispersione

Con dispersione si intende la probabilità che la cella sarà visitata almeno una volta dal parassitoide. Il grafico indica quindi la capacità di dispersione in quel paesaggio per quel punto di lancio.

```{r plot heatmap dispersione, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
do.call(grid.arrange,c(plot_dispersion, ncol = (length(raster_files)/(length(raster_dir)-1))))
```

```{r plot dispersion, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"dispersione")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))
        ) +
  labs(x=NULL,y = NULL)
```

##### Mortalità

Con Mortalità si intende la probabilità di assorbimento nella cella visitata. Il grafico indica quindi la probabilità di "assorbimento" in quel paesaggio per quel punto di lancio

```{r plot heatmap mortalita, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
do.call(grid.arrange,c(plot_mortality, ncol = (length(raster_files)/(length(raster_dir)-1))))
```

```{r plot mortality, echo=FALSE, fig.ext='svg', fig.width=10, message=FALSE, warning=FALSE}
ggplot(filter(rast_df_br,str_detect(data_frame,"mortalita")),aes(x=data_frame,y=value))+
  geom_violin(na.rm = T,scale="area")+
  scale_y_continuous(
    trans='log10'
    ,breaks=trans_breaks('log10', function(x) 10^x),
    labels=trans_format('log10', math_format(10^.x))
    ) +
  labs(x=NULL,y = NULL)
```
