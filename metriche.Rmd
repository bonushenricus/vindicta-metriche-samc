---
title: "metriche"
author: "Enrico Gabrielli F.A.R.M. Facilitazioni Agroecologiche Regionali Mobili"
date: "17/1/2023"
output:
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# VINDICTA progetto 16.1 PSR Emilia-Romagna 2014-2020

## azione 3, analisi agroecosistema

### Calcolo delle metriche di analisi dell'agroecosistema

```{r pacchetti, echo=FALSE, message=FALSE}
library(raster) # per analizzare il raster
library(httr)
library(tidyverse)
library(ggplot2)
library(terrainr)
library(patchwork)
library(stringr)
library(gridExtra)
```

### Visualizzazione della resistenza

```{r resistance, echo=FALSE, message=FALSE}
#options(width = 200) #studiare 
cartella <- './raster' #cartella in cui si trovano i raster in formato tif
files <- list.files(path = cartella,pattern = '*resistance_norm.tif',full.names = T)
resistance_norm <- vector("list", length(files))
names(resistance_norm) <- str_extract(files, "(?<=\\+)[[:alpha:]]+(?=_)") #i file iniziano con + e con il nome dell'azienda
for (i in 1:length(files)) { # importo i raster
  resistance_norm[[i]] <- raster(files[i])
}
#di seguito i passaggi per usare ggplot2 per visualizzare la carta
resistance_norm_df <- lapply(resistance_norm,function(x) #ggplot usa dei dataframe
  raster::as.data.frame(x,xy=TRUE #quindi trasformo i raster in dataframe, del valore e xy (che serve per fare i tile detta anche heatmap)
                        ,centroids=T #il centroide pare non cambi niente ma mi sembrava corretto
                        )
  )
nomecolonne <- c("x","y","value") #il valore ha il nome del raster, invece voglio lo stesso x tutti i raster, ovvero "value"
resistance_norm_df <- lapply(resistance_norm_df,setNames,nomecolonne)
fun_plot_resistance <- function(x) ggplot(x,aes(x=x,y=y))+ #funzione per l'heatmap
  geom_tile(aes(fill=value))+
  scale_fill_gradient(low = "green3",
                      high = "white",
                      trans='log',
                      label = function(x) sprintf("%.2f", x),
                      limits=c(0.01, 1) #per avere le legende dei vari plot confrontabili
                      ) +
  theme(legend.position = "bottom",
        legend.title = element_blank(), #rimuovi testi che non servono come "value" in legenda
        legend.key.width = unit(1.5,'cm'), #change legend key width
        ) +
  labs(x = NULL, y = NULL) + #tolgo i label agli assi
  coord_fixed() #per avere un quadrato sempre
plot_resistance_norm <- lapply(resistance_norm_df,fun_plot_resistance)
nomi_plot <- as.list(names(resistance_norm_df)) #per aggiungere i titoli per ogni plot faccio una lista dei nomi dei raster-dataframe
fun_nomi_plot <- function(plot,nomi) {plot + ggtitle(nomi)} #funzione per aggiungere il titolo ai plot già creati
plot_resistance_norm <- mapply(plot=plot_resistance_norm,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
```

```{r heatmap resistenza, echo=FALSE, fig.width=8, dev='svg',dpi=300}
do.call("grid.arrange", c(plot_resistance_norm, ncol = length(plot_resistance_norm))) #grid.arrange serve a visualizzare i plot nella lista uno a fianco dell'altro (tante colonne quanti sono i plot nella lista). Purtroppo non riesco a capire come farla più grande
```


```{r violin resistenza, echo=FALSE}
#non posso far diventare la lista di dataframe dai raster un solo dataframe, perché potrebbero essere di diversa grandezza. quindi devo lavorare direttamente su resistance_norm_df già creato in precedenza, cioé la lista di dataframe
fun_violin_plot <- function(df) gg <- ggplot(df,aes(x='',y=value)) +
  geom_violin(na.rm = T,scale="count") + #funzione di ggplot per grafici a violino (boxplot+density). x bisogna segnarlo
  coord_cartesian (ylim = c(0, 1)) + #per avere grafici non automatici nelle scale, quindi comparabili 
  labs(x = NULL, y = NULL) #tolgo i label agli assi
resistance_violin_plot <- lapply(resistance_norm_df,fun_violin_plot) #la funzione va per ogni oggetto della lista di dataframe dei valori ricavati dai raster
# riprendo i nomi dei plot
resistance_violin_plot <- mapply(plot=resistance_violin_plot,nomi=nomi_plot,fun_nomi_plot,SIMPLIFY = F) #ho due liste, una dei plot e una dei nomi, applico una funzione multipla, simplify=F serve a ricreare due liste, altrimenti per ogni layer dei plot usa la funzione
resistance_norm_df_v <- lapply(resistance_norm,function(x) #creare una lista di vettori solo con i valori per fare le medie
  as.vector(x))
media_plot <- lapply(resistance_norm_df_v,mean) #calcolo la media della resistenza
fun_plot_medie <- function(plot,medie) {plot + geom_point(y=medie)} #funzione per aggiungere il punto medio ai plot già creati
resistance_violin_plot <- mapply(plot=resistance_violin_plot,medie=media_plot,fun_plot_medie,SIMPLIFY = F) #aggiungo il punto medio
```

```{r plot violin resistenza, echo=FALSE, fig.width=8,dev='svg'}
do.call("grid.arrange", c(resistance_violin_plot, ncol = length(resistance_violin_plot))) #grid.arrange serve a visualizzare i plot nella lista uno a fianco dell'altro (tante colonne quanti sono i plot nella lista). Purtroppo non riesco a capire come farla più grande
```
